"""
Задача 1: Даны два списка, нужно вернуть элементы, которые есть в 1-ом списке, но нет во 2-ом. Оценить эффективность своего решения. 
    
Решение:
Нет условия, что списки не содержат дубликаты. 
Поэтому было принято решение сделать hashmap с количеством элементов первого списка, 
а затем вычесть количество аналогичных элементов второго списка.
Те ключи, где значения останутся больше нуля, не были найдены во втором.
Т.к. нет условия сохранять порядок, то просто создаем результирующий список из hashmap.

Сложность решения:
Time complexity:
Здесь за n примем общее число элементов в двух списках. Для краткости сразу сократим константы.
O(n) - подсчет элементов первого списка
O(n) - проход по второму массиву
O(n) - заполнение результрующего массива

Space complexity:
O(n) - в худшем случае результирующий массив будет равен длине всего первого списка
    
"""

tests = [
    # Непересекающиеся списки
    {
        "list1": [1,2,3],
        "list2": [4,5,6],
        "expected": [1,2,3]
    },
    # Частичное пересечение
    {
        "list1": [1,2,3,4],
        "list2": [3,4,5,6],
        "expected": [1, 2]
    },
    # Полное пересечение
    {
        "list1": [1,2,3],
        "list2": [3,2,1],
        "expected": []
    },
    # Второй список пуст
    {
        "list1": [1,2,3],
        "list2": [],
        "expected": [1,2,3]
    },
    # Первый список пуст
    {
        "list1": [],
        "list2": [1,2,3],
        "expected": []
    },
    # Дубликаты
    {
        "list1": [4,1,2,3,2,1,3,4],
        "list2": [3,2,4,1,3,4,-1],
        "expected": [1,2]
    }
    
]


def get_list_difference_elements(list1, list2):
    
    result = []
    counter_list1 = dict()

    # Выполним проход по первому массиву и посчитаем количество элементов
    for element in list1:
        counter_list1[element] = counter_list1.get(element, 0) + 1

    # Выполним проход по второму массиву, чтобы вычесть из счетчиков найденные элементы
    for element in list2:
        if counter_list1.get(element) is not None:
            counter_list1[element] -= 1

    # Ключи, чьи значения положительные - элементы массива, которых нет во втором массиве
    for key, value in counter_list1.items():
        while value > 0:
            result.append(key)
            value -= 1

    return result
    

# Прогон тест-кейсов
for test in tests:
    assert test["expected"] == get_list_difference_elements(test["list1"], test["list2"])


"""
Задача 2: Дан массив целых чисел. Нужно удалить из него нули. Можно использовать только О(1) дополнительной памяти. 
Пример:
    array = [0, 1, 0, 0, 4, 5, 6, 7, 0, 8, -4, 0] # input
    [1, 4, 5, 6, 7, 8, -4] # output
    
Решение:
Перемещение нулей в конец списка, а затем удаление через pop() позволит воспользоваться той же памятью.

Сложность решения:
Time complexity:
O(n) - проход по массиву (перемещение элементов O(1))
O(n) - удаление нулей (худший случай - весь список состоит из нулей)
Итоговая сложность линейная, O(n) 

Space complexity:
O(1) - использован входной список без доп.структур
    
"""

tests = [
    # Нули отсутствуют
    {
        "array": [1,2,3],
        "expected": [1,2,3]
    },
    # Нули присутствуют в середине списка
    {
        "array": [1,0,2,0,3],
        "expected": [1,2,3]
    },
    # Нули по краям списка
    {
        "array": [0,1,0,2,0,3,0,0],
        "expected": [1,2,3]
    },
    # Список пуст
    {
        "array": [],
        "expected": []
    },
    # Список состоит из нулей
    {
        "array": [0,0,0,0],
        "expected": []
    },
    # Список пуст
    {
        "array": [],
        "expected": []
    },
    # Пример из условия
    {
        "array": [0, 1, 0, 0, 4, 5, 6, 7, 0, 8, -4, 0],
        "expected": [1, 4, 5, 6, 7, 8, -4]
    }
    
]

def exclude_zeros_from_array(array):
    left_pointer = 0
    
    for right_pointer in range(len(array)):
            
        # Если правый счетчик указывает на ненулевое число, а левый - на 0, производим замену
        if array[right_pointer] != 0 and array[left_pointer] == 0:
            array[left_pointer], array[right_pointer] = array[right_pointer], array[left_pointer]
            
        # Если элемент на левом счетчике != 0, то обмен уже был произведен, счетчик нужно сдвинуть
        if array[left_pointer] != 0:
            left_pointer += 1
        
    # Удаляем перемещенные в конец списка нули        
    while array and array[-1] == 0:
        array.pop()

    return array
    
    
# Прогон тест-кейсов
for test in tests:
    assert test["expected"] == exclude_zeros_from_array(test["array"])
    

